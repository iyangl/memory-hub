# Memory Hub 重新设计目标

> 本文档记录经过重新梳理后的设计意图，作为后续实现的基准。
> 文档中所有具体的功能名称（如登录、支付等）均为示意性举例，不代表必选项或预设内容。实际使用时，所有话题和文件由 AI 根据项目实际情况动态生成。

## 定位

**项目知识库 + 按需检索**。让 AI 在工作过程中主动取到所需的上下文，而不是靠用户每次手动喂，也不是会话开始一次性加载大包。

## 存什么

只存**代码读不到的内容**：

- 设计决策：为什么这样做、考虑过哪些方案、为什么否掉
- 约束集：不要做什么、哪些边界不能碰
- 演进历史：以前是什么做法、因为什么改成现在这样
- 隐性前提：依赖某个外部约定或业务规则，代码里看不出来
- 已知取舍：这里性能差是故意的，原因是什么

代码本身能读到的（函数做什么、文件结构、实现逻辑）不存。

## 存储结构

纯 markdown 文件，四个桶作为知识命名空间。每个桶有固定的基础文件，话题膨胀时可拆分出独立文件。

```
.memory/
├── pm/
│   └── decisions.md            # 基础文件：需求结论与产品决策
├── architect/
│   ├── tech-stack.md           # 基础文件：技术栈、关键依赖、使用方式与限制
│   └── decisions.md            # 基础文件：设计决策日志（Decision Log 格式）
├── dev/
│   └── conventions.md          # 基础文件：代码约定、命名规则、模式
├── qa/
│   └── strategy.md             # 基础文件：测试策略与质量约束
└── catalog/
    ├── topics.md               # 轻量目录：所有内容的统一入口
    └── modules/                # 详细索引：每个功能域一个文件
        └── <topic>.md          # AI 根据项目实际功能域创建
```

### 基础文件规则

- 基础文件在 init 时创建，不允许删除或重命名
- 内容少时，所有知识都写在基础文件里
- 当某个话题膨胀到影响阅读时（参考值：单个文件超过 200 行），AI 拆分出独立文件，并在 `topics.md` 里注册
- architect 桶的 `decisions.md` 采用 Decision Log 格式：背景、备选方案、选择原因、后果

## Catalog 的定位

轻量入口索引，不做 AST 扫描。分两层，避免全量加载浪费 token：

### 第一层：`topics.md`（轻量目录）

所有内容的统一入口，AI 每次接到任务时必读。保持简短：每条记录不超过一行（话题名 + 文件路径 + 一句话描述），话题分组用标题，不放任何详细内容。同时索引代码模块和知识文件：

```markdown
## 代码模块
- <模块A> — 一句话描述
- <模块B> — 一句话描述

## 知识文件
### <话题X>
- pm/decisions.md #<锚点> — 相关需求结论
- architect/decisions.md #<锚点> — 相关设计决策
- architect/<拆分文件>.md — 拆分：该话题的详细演进

### <话题Y>
- architect/tech-stack.md #<锚点> — 相关技术选型
- dev/conventions.md #<锚点> — 相关代码约定
```

基础文件内容涵盖多个话题时，用 `#锚点` 标注具体段落位置。

### 第二层：`modules/<topic>.md`（详细索引）

每个功能域一个文件，列出该域涉及的关键文件和说明。AI 只在确定要处理某个功能域时才读取对应文件。只索引关键文件（入口、核心模块、公共工具、配置），不逐一登记所有文件。

### 检索流程

```
1. catalog.read topics     → 读轻量目录，定位相关话题（几十行）
2. catalog.read <module>   → 只读该功能域的详细索引（十几行）
3. memory.read <bucket> <file> → 读相关知识文件
```

每一步只取最小需要的那一块。`memory.search` 作为 catalog 失效时的兜底安全网。

## 原子 Skill

AI 在工作过程中主动调用：

| Skill | 说明 |
|-------|------|
| `memory.init` | 初始化：生成 catalog + 基础文件 |
| `memory.read <bucket> <file>` | 精准读取某个桶的某个文件 |
| `memory.list <bucket>` | 列出桶内所有文件 |
| `memory.search <query>` | 跨桶全文检索 |
| `memory.write <bucket> <file> --topic <话题名> --summary <描述> [--anchor <锚点>] [--mode append\|overwrite]` | 写知识文件 + 自动更新 topics.md 知识索引；内容通过 stdin 传入 |
| `catalog.read [topics\|<module>]` | 读取轻量目录或某个功能域的详细索引 |
| `catalog.update` | 仅更新代码模块索引（catalog/modules/* 和 topics.md 代码模块部分） |
| `catalog.repair` | 自愈：扫描一致性并修复，输出 fixed + manual_actions |

### catalog.repair 契约

固定检查项：
- 死链接：topics.md 指向不存在的文件
- 缺注册：桶内文件存在但 topics.md 未索引
- 重复 topic：同一话题在 topics.md 中出现多次
- 无效锚点：`#锚点` 指向的标题在目标文件中不存在

输出分三段：
- `fixed`：脚本自动修复的项（删除死链接）
- `ai_actions`：AI 自愈的项（缺注册 → AI 读文件生成话题名/描述后调用 `memory.write` 补注册；可匹配的无效锚点 → AI 找到近似标题后自动修正）
- `manual_actions`：需要人工确认的项（重复 topic 的合并；无法找到近似标题的无效锚点）

触发时机：
- `memory.init` 完成后自动执行一次
- `catalog.update` 完成后自动执行一次
- `memory.read` 命中失效锚点时触发一次修复流程

## 关键差异点

不是 session start 一次性加载，而是 **AI 在需要的时候主动取，取最小够用的那一块**，用完不常驻。这是市面上现有工具（Mem0、Memory Bank MCP 等）没有解决好的问题。

## 实现载体

Skill（AI 直接执行的提示词流程），不是 MCP 服务。无服务进程、无数据库、无协议层。AI 行为指引写在项目 CLAUDE.md 里，告诉 AI 何时该主动检索、何时该写回。

每个原子 skill 背后对应一个本地脚本（shell/python），AI 通过调用脚本而不是直接读写文件。脚本统一 JSON 输出和错误码，使 skill 行为可测试、可回归。

### 统一 I/O 结构

所有脚本返回统一的 JSON envelope：

```json
{
  "ok": true,
  "code": "SUCCESS",
  "data": {},
  "ai_actions": [],
  "manual_actions": []
}
```

退出码约定：
- 0 = 成功
- 1 = 业务错误（具体原因看 code 字段）
- 2 = 系统错误

### 职责分工

- `memory.write`：负责知识文件的写入 + topics.md 知识文件索引部分的更新
- `catalog.update`：仅负责代码模块索引（`catalog/modules/*` 和 topics.md 代码模块部分）的变更

## 可靠性保障

### 写入一致性

`memory.write` 合并了"写知识文件"和"更新 topics.md"两个操作。脚本内部保证强一致优先：先写知识文件，再更新 topics.md。跨两个文件无法做到严格原子（rename 只保证单文件原子），存在中间态窗口。

应对策略：`catalog.repair` 自愈命令（详见原子 Skill 章节），在写入后自动检查一致性——死链接自动删除，缺注册和无效锚点列入 `manual_actions` 由人工补录。

### 并发策略

当前设计面向单用户场景，不引入并发控制。触发条件：一旦出现真实的跨端覆盖写案例，引入 `.lock` 文件作为低成本兜底（写前创建，写完删除，发现 lock 存在则等待或报错）。

## 初始化（memory.init）

已有项目第一次接入 Memory Hub 时，需要执行初始化。

### 做什么

AI 扫描项目，生成 Catalog 和基础文件：

**1. 生成 Catalog**

- 生成 `catalog/topics.md`：按功能域列出话题名 + 一句话描述
- 生成 `catalog/modules/<topic>.md`：每个功能域的关键文件列表
- 只索引关键文件（入口、核心模块、公共工具、配置），不逐一登记所有文件
- AI 通过读目录、读关键文件（package.json、入口文件、配置文件等）完成，不需要 AST 扫描

**2. 生成基础知识文件**

- `architect/tech-stack.md`：全局技术栈、关键依赖、使用方式与限制
- `dev/conventions.md`：目录命名规则、模块组织方式、代码约定
- `pm/decisions.md`：创建空文件，等待后续填充
- `architect/decisions.md`：创建空文件，等待后续填充
- `qa/strategy.md`：创建空文件，等待后续填充

**3. 注册到 topics.md**

将所有基础文件和代码模块统一注册到 `topics.md`，确保从第一次会话开始就有完整的入口索引。

**4. 质量门：输出 unknowns 段**

init 完成后输出 `unknowns` 列表，列出 AI 不确定归属的文件或目录（无法明确归入任何功能域的），要求用户确认一次。随后自动执行 `catalog.repair` 检查首版索引的一致性。

### 不做什么

- 不猜设计决策的"为什么"——代码能告诉你"是什么"，但"为什么这样做"只有人知道
- 不生成 PM 和 QA 桶的内容——需求历史和测试策略无法从代码推断

### 初始化后的状态

```
.memory/
├── pm/
│   └── decisions.md            # 空，等待后续填充
├── architect/
│   ├── tech-stack.md           # 自动生成：技术栈、关键依赖、使用方式
│   └── decisions.md            # 空，等待后续填充
├── dev/
│   └── conventions.md          # 自动生成：目录结构、命名约定、模块组织
├── qa/
│   └── strategy.md             # 空，等待后续填充
└── catalog/
    ├── topics.md               # 自动生成：统一入口索引
    └── modules/                # 自动生成：每个功能域的关键文件
        └── ...
```

从第一次会话开始 AI 就有基本的项目认知，后续每次会话逐步积累更深的知识。

## AI 行为规则

### 何时 Search / Read

**触发条件：AI 即将修改代码或做决策之前。**

**topics.md 每次必读**：AI 跨会话无记忆，无法可靠判断自己是否"已知"文件路径。topics.md 严格限制每条一行，100 个话题约 4000 tokens（占上下文 1%-2%），成本可接受，换来的是确定性——AI 永远基于最新索引工作。

**例外**：任务类型为 `quick_fix`（目标文件已明确、单点修改）时，可跳过 `catalog.read topics`，直接操作目标文件。

标准路径：
1. **接到任务时**，先判断任务类型：
   - `quick_fix`（目标文件明确的单点修改）→ 可跳过 catalog.read topics，直接操作
   - `scoped_change` / `feature_work` → 先 `catalog.read topics`
2. **定位到相关话题后**，`memory.read` 读取对应知识文件的完整内容。
3. **要修改某个功能模块时**，`catalog.read <module>` 读取该功能域的详细索引，找到涉及的关键代码文件，然后去读代码。
4. **修改代码或做设计决策前**，至少加载 1 个相关 `memory.read`（确认无约束冲突）。

兜底路径：
- 如果 `catalog.read topics` 中找不到相关话题，使用 `memory.search <关键词>` 跨桶全文检索。search 是 catalog 失效时的安全网，不是常规第一步。

不需要 search 的场景：纯粹的格式调整、明确的单行 bug fix、用户已经把所有上下文给全了。

### 何时 Write / Update

**触发条件：产生了新的、代码里读不到的知识。**

1. **做出设计决策时** — 讨论了多个方案、选了一个、否掉了其他的。写入 `architect/<话题>.md`，用 Decision Log 格式。
2. **发现或确认约束时** — "这个模块不能用 X"、"这里必须保持 Y 兼容"。写入对应桶。
3. **需求讨论达成结论时** — 写入 `pm/<话题>.md`。
4. **建立了代码约定时** — "错误处理统一用这个模式"、"命名规则是这样"。写入 `dev/<话题>.md`。
5. **修改了文件结构时** — 标记 `catalog_dirty = true`。
6. **往基础文件新增话题段落时** — 同步在 `topics.md` 里注册该话题及锚点，确保后续 AI 能通过 catalog 定位到。

**任务结束时**：
- 若 `catalog_dirty = true` → 执行 `catalog.update`
- 若本次任务发生过 `memory.write` 或 `catalog.update` → 执行 `catalog.repair`，处理返回结果：
  - `ai_actions` 非空 → AI 立即自愈（补注册、修正锚点），完成后再次执行 `catalog.repair` 确认清零
  - `manual_actions` 非空 → 任务结束前向用户报告，列出需要人工确认的项

不需要 write 的场景：只是读了代码、只是执行了已有方案、没有产生新的"为什么"或"不要什么"。

**判断标准：如果下一个会话的 AI 不知道这件事，会不会做出错误的决定？会的话就写，不会就不写。**

### 决策演进的记录方式

当方案被推翻、修改时，不删除旧决策，而是追加新决策并标注废弃关系：

```markdown
### 决策 1 — <日期>
背景：<需要解决的问题>
方案：
- A: <方案描述> ← 选择
- B: <方案描述>
选择原因：<为什么选 A>

### 决策 2 — <日期>
背景：决策 1 的方案 A 出现 <具体问题>
方案：
- 回退到方案 B ← 选择
- C: <新方案描述>
选择原因：<为什么改选 B>
废弃：决策 1 的方案 A 不再使用
```

被记忆的：最终方案、为什么不用旧方案、为什么否掉其他备选。
不被记忆的：具体代码实现细节、测试日志、重构 diff。

### 文件管理规则

AI 不随意创建文件，遵循以下流程：

1. 先 `catalog.read topics`，看当前话题是否已有对应的知识文件
2. 有 → 追加到已有文件（通过 `memory.write`）
3. 没有 → 通过 `memory.write` 创建新文件（自动注册到 topics.md 知识索引）

## 与现有实现的差距

| 现有实现 | 新设计 |
|---------|--------|
| MCP 服务进程 | 无，纯文件 |
| SQLite 数据库 | 无，markdown 文件 |
| 冲突检测 / 乐观锁 | 无，单人场景不需要 |
| 会话边界 pull/push | 无，随时检索/写回 |
| AST 扫描依赖图 | 无，手动维护 index.md |
| 角色状态版本链 | 无，文件本身就是最新状态 |
